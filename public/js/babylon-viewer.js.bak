// public/js/babylon-viewer.js
// Unified viewer script: capture helpers + BabylonViewerJS with camera control methods.
// Safe to overwrite your existing file with this.

(function(global){
"use strict";

/* ---------------------------
   Capture / Upload helpers
   --------------------------- */

// simple download from canvas (visible resolution)
window.captureCanvasAndDownload = function({ filename = null, quality = 0.9 } = {}) {
    const canvas = document.getElementById('renderCanvas');
    if (!canvas) { alert('Canvas not found'); return; }
    try {
        const dataUrl = canvas.toDataURL('image/jpeg', quality);
        filename = filename || 'snapshot-' + (new Date()).toISOString().replace(/[:.]/g,'-') + '.jpg';
        const a = document.createElement('a');
        a.href = dataUrl;
        a.download = filename;
        document.body.appendChild(a);
        a.click();
        a.remove();
    } catch (err) {
        console.error('captureCanvasAndDownload error', err);
        alert('Failed to capture canvas: ' + (err.message || err));
    }
};

// upload using canvas visible resolution
async function captureCanvasAndUploadImpl({ endpointPath = '/save_snapshot.php', quality = 0.9, filenameHint = null } = {}) {
    const canvas = document.getElementById('renderCanvas');
    if (!canvas) throw new Error('Canvas element not found');

    let dataUrl;
    try {
        dataUrl = canvas.toDataURL('image/jpeg', quality);
    } catch (e) {
        throw new Error('Failed to read canvas. Canvas may be tainted by cross-origin textures. See console for details.');
    }

    // simple guard
    const approxBytes = Math.ceil((dataUrl.length - dataUrl.indexOf(',') - 1) * 3 / 4);
    const maxBytes = 32 * 1024 * 1024; // 32MB guard (adjust server-side if needed)
    if (approxBytes > maxBytes) throw new Error('Snapshot too large: ' + Math.round(approxBytes/1024) + ' KB');

    const payload = { image: dataUrl, filename: filenameHint || null };

    const res = await fetch(endpointPath, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(payload)
    });
    const text = await res.text().catch(()=>null);
    let json = null;
    try { json = text ? JSON.parse(text) : null; } catch(e){}
    if (!res.ok) {
        const msg = (json && json.error) ? json.error : (text || ('HTTP ' + res.status));
        throw new Error('Upload failed: ' + msg);
    }
    if (!json || !json.success) throw new Error('Server error saving snapshot: ' + (json && json.error ? json.error : text));
    return json;
}
window.captureCanvasAndUpload = captureCanvasAndUploadImpl;

/* ---------------------------
   High-res screenshot helpers (Babylon ScreenshotTools)
   --------------------------- */

async function captureHighResSnapshot({ scene, camera, size = 2048, quality = 0.95, upload = false, endpointPath = '/save_snapshot.php', filenameHint = null } = {}) {
    if (!scene || !camera) throw new Error('scene or camera missing for high-res capture');
    return new Promise((resolve, reject) => {
        try {
            BABYLON.ScreenshotTools.CreateScreenshotUsingRenderTarget(
                scene.getEngine(),
                camera,
                size,
                (dataUrl) => {
                    if (!upload) {
                        const filename = filenameHint || 'snapshot-' + new Date().toISOString().replace(/[:.]/g,'-') + '.jpg';
                        const a = document.createElement('a');
                        a.href = dataUrl;
                        a.download = filename;
                        document.body.appendChild(a);
                        a.click();
                        a.remove();
                        resolve({ url: dataUrl, filename });
                        return;
                    }
                    // upload flow
                    fetch(endpointPath, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ image: dataUrl, filename: filenameHint || null })
                    }).then(r => r.json()).then(json => {
                        if (json && json.success) resolve(json);
                        else reject(new Error('Upload failed: ' + (json && json.error ? json.error : 'unknown')));
                    }).catch(err => reject(err));
                },
                'image/jpeg',
                quality
            );
        } catch (err) {
            reject(err);
        }
    });
}

window.captureCanvasAndDownloadHighRes = function({ size = 2048, quality = 0.95, filenameHint = null } = {}) {
    const viewer = window.myViewer;
    if (!viewer || !viewer.scene || !viewer.camera) {
        alert('Viewer not ready');
        return;
    }
    captureHighResSnapshot({ scene: viewer.scene, camera: viewer.camera, size, quality, upload: false, filenameHint })
        .catch(e => { console.error('High-res download failed', e); alert(e.message || e); });
};

window.captureCanvasAndUploadHighRes = function({ size = 2048, quality = 0.95, endpointPath = '/save_snapshot.php', filenameHint = null } = {}) {
    const viewer = window.myViewer;
    if (!viewer || !viewer.scene || !viewer.camera) {
        alert('Viewer not ready');
        return;
    }
    captureHighResSnapshot({ scene: viewer.scene, camera: viewer.camera, size, quality, upload: true, endpointPath, filenameHint })
        .then(json => { console.log('Uploaded snapshot:', json); alert('Snapshot saved at ' + json.url); })
        .catch(e => { console.error('High-res upload failed', e); alert(e.message || e); });
};

/* ---------------------------
   BabylonViewerJS core
   --------------------------- */

function BabylonViewerJS(options = {}) {
    options = options || {};
    this.canvas = document.getElementById(options.canvasId || 'renderCanvas');
    if (!this.canvas) throw new Error('Canvas not found');
    this.engine = new BABYLON.Engine(this.canvas, true, { preserveDrawingBuffer: true, stencil: true });
    this.scene = new BABYLON.Scene(this.engine);

    this.modelsListEndpoint = options.modelsListEndpoint || '/babylon_models.php';
    this.modelEndpoint = options.modelEndpoint || null;

    this.rootMesh = null;
    this.autoRotate = false;

    // init and camera
    this._initScene();

    // save initial camera state after scene and camera created
    try { this._saveInitialCameraState(); } catch(e){ console.warn('_saveInitialCameraState() at ctor', e); }

    var self = this;
    window.addEventListener('resize', function(){ try { self.engine.resize(); } catch(e){} });
    this.engine.runRenderLoop(function() {
        try {
            if (self.autoRotate && self.rootMesh) { self.rootMesh.rotation.y += 0.005; }
            self.scene.render();
        } catch(e){}
    });
}

/* init default scene, camera, lights */
BabylonViewerJS.prototype._initScene = function(){
    this.camera = new BABYLON.ArcRotateCamera("camera", Math.PI / 2, Math.PI / 2.5, 3, BABYLON.Vector3.Zero(), this.scene);
    this.camera.attachControl(this.canvas, true);
    this.camera.wheelDeltaPercentage = 0.01;

    var hemi = new BABYLON.HemisphericLight("hemi", new BABYLON.Vector3(0,1,0), this.scene);
    hemi.intensity = 0.9;
    var dir = new BABYLON.DirectionalLight("dir", new BABYLON.Vector3(-0.5,-1,0.5), this.scene);
    dir.position = new BABYLON.Vector3(5,10,-5);
    dir.intensity = 0.6;

    this.scene.clearColor = new BABYLON.Color4(0.06,0.06,0.06,1);
    var ground = BABYLON.MeshBuilder.CreateGround("ground", {width:10, height:10}, this.scene);
    ground.position.y = -1.1;
    ground.isPickable = false;
    ground.visibility = 0;
};

/* fetch list endpoint */
BabylonViewerJS.prototype.fetchModelList = async function(){
    var res = await fetch(this.modelsListEndpoint, {cache: 'no-cache'});
    if (!res.ok) throw new Error('Failed to fetch list: ' + res.status);
    return await res.json();
};

/* load model */
BabylonViewerJS.prototype.loadModelById = async function(id){
    if (this.modelEndpoint) {
        var res = await fetch(this.modelEndpoint + '?id=' + encodeURIComponent(id));
        if (!res.ok) throw new Error('Model endpoint error');
        var meta = await res.json();
        return await this.loadModel(meta.url);
    } else {
        var url = id;
        if (!url.match(/^\//) && !url.match(/^https?:\/\//)) {
            var list = await this.fetchModelList();
            var found = list.find(function(x){ return x.id === id || x.name === id; });
            if (found) url = found.url;
        }
        return await this.loadModel(url);
    }
};

BabylonViewerJS.prototype.loadModel = function(url){
    var self = this;
    if (this.rootMesh) {
        try {
            this.rootMesh.getChildMeshes().forEach(function(m){ m.dispose(); });
            this.rootMesh.dispose();
        } catch (e){}
        this.rootMesh = null;
    }

    return new Promise(function(resolve, reject){
        BABYLON.SceneLoader.Append("", url, self.scene, function(scene){
            var root = null;
            if (scene.meshes && scene.meshes.length) {
                root = new BABYLON.TransformNode("modelRoot", self.scene);
                scene.meshes.forEach(function(m){
                    if (m.name === "Ground" || m.name === "ground") return;
                    try { m.parent = root; } catch(e){}
                });
            } else {
                root = scene.rootNodes.length ? scene.rootNodes[0] : null;
            }
            if (!root) root = new BABYLON.TransformNode("modelRoot", self.scene);
            self.rootMesh = root;
            try { self._frameModel(); } catch(e){}
            resolve({ scene: scene });
        }, function(evt){ /* progress */ }, function(err){
            reject(err);
        });
    });
};

BabylonViewerJS.prototype._frameModel = function(){
    try {
        var meshes = this.rootMesh && this.rootMesh.getChildMeshes ? this.rootMesh.getChildMeshes() : (this.scene.meshes || []);
        if (!meshes.length) return;
        var min = new BABYLON.Vector3(Number.POSITIVE_INFINITY,Number.POSITIVE_INFINITY,Number.POSITIVE_INFINITY);
        var max = new BABYLON.Vector3(Number.NEGATIVE_INFINITY,Number.NEGATIVE_INFINITY,Number.NEGATIVE_INFINITY);
        meshes.forEach(function(m){
            var info = m.getBoundingInfo();
            var bmin = info.boundingBox.minimum.add(m.getAbsolutePosition());
            var bmax = info.boundingBox.maximum.add(m.getAbsolutePosition());
            min = BABYLON.Vector3.Minimize(min, bmin);
            max = BABYLON.Vector3.Maximize(max, bmax);
        });
        var center = min.add(max).scale(0.5);
        var dims = max.subtract(min);
        var radius = Math.max(dims.x, dims.y, dims.z) * 0.5;
        this.camera.target = center;
        var desiredRadius = Math.max(2.0, radius * 3.0);
        this.camera.radius = desiredRadius;
    } catch(e){
        console.warn('frameModel failed', e);
    }
};

/* ---------------------------
   Camera control helpers (prototype)
   --------------------------- */

BabylonViewerJS.prototype._saveInitialCameraState = function() {
    if (!this.camera) return;
    try {
        this._initialCameraState = {
            alpha: this.camera.alpha,
            beta: this.camera.beta,
            radius: this.camera.radius,
            target: this.camera.target ? this.camera.target.clone() : new BABYLON.Vector3(0,0,0)
        };
    } catch(e) { console.warn('_saveInitialCameraState failed', e); }
};

BabylonViewerJS.prototype.resetCamera = function(animate = false) {
    if (!this._initialCameraState) return;
    const s = this._initialCameraState;
    this.setCameraAlphaBetaRadius(s.alpha, s.beta, s.radius, animate);
    this.setCameraTarget(s.target, animate);
};

BabylonViewerJS.prototype.setCameraAlphaBetaRadius = function(alpha, beta, radius, animate = false) {
    if (!this.camera) return;
    beta = Math.max(0.01, Math.min(3.13, beta));
    if (animate) {
        const dur = 300;
        const start = performance.now();
        const from = {a: this.camera.alpha, b: this.camera.beta, r: this.camera.radius};
        const to = {a: alpha, b: beta, r: radius};
        const self = this;
        function tick(now) {
            const t = Math.min(1, (now - start) / dur);
            const ease = t * (2 - t);
            self.camera.alpha = from.a + (to.a - from.a) * ease;
            self.camera.beta  = from.b + (to.b - from.b) * ease;
            self.camera.radius= from.r + (to.r - from.r) * ease;
            if (t < 1) requestAnimationFrame(tick);
        }
        requestAnimationFrame(tick);
    } else {
        this.camera.alpha = alpha;
        this.camera.beta = beta;
        this.camera.radius = radius;
    }
};

BabylonViewerJS.prototype.setCameraTarget = function(target, animate = false) {
    if (!this.camera) return;
    let vec = target;
    if (!(target instanceof BABYLON.Vector3)) {
        vec = new BABYLON.Vector3(target.x || 0, target.y || 0, target.z || 0);
    }
    if (animate) {
        const dur = 300;
        const start = performance.now();
        const from = this.camera.target.clone();
        const to = vec.clone();
        const self = this;
        function tick(now) {
            const t = Math.min(1, (now - start) / dur);
            const ease = t * (2 - t);
            const cur = BABYLON.Vector3.Lerp(from, to, ease);
            self.camera.setTarget(cur);
            if (t < 1) requestAnimationFrame(tick);
        }
        requestAnimationFrame(tick);
    } else {
        this.camera.setTarget(vec);
    }
};

BabylonViewerJS.prototype.panByPixels = function(dx, dy, sensitivity = 1.0) {
    if (!this.camera || !this.scene || !this.engine) return;
    const canvas = this.canvas;
    const height = canvas.clientHeight || canvas.height || 1;
    const distance = Math.max(0.0001, this.camera.radius);
    const worldHeight = 2 * distance * Math.tan(this.camera.fov / 2);
    const worldPerPixel = (worldHeight / Math.max(1, height)) * sensitivity;
    const forward = this.camera.target.subtract(this.camera.position).normalize();
    const right = BABYLON.Vector3.Cross(forward, this.camera.upVector).normalize();
    const up = BABYLON.Vector3.Cross(right, forward).normalize();
    const offset = right.scale(-dx * worldPerPixel).add(up.scale(dy * worldPerPixel));
    this.camera.setTarget(this.camera.target.add(offset));
};

BabylonViewerJS.prototype.changeRadiusBy = function(delta) {
    if (!this.camera) return;
    this.camera.radius = Math.max(0.01, this.camera.radius + delta);
};

BabylonViewerJS.prototype.setOrbitSensitivity = function(multiplier) {
    if (!this.camera) return;
    try {
        // wheelPrecision controls zoom sensitivity (smaller -> faster)
        this.camera.wheelPrecision = Math.max(0.1, 3 / multiplier);
        // panning sensibility: higher multiplier => smaller number here
        if (typeof this.camera.panningSensibility === 'number') {
            this.camera.panningSensibility = 100 / Math.max(0.1, multiplier);
        }
    } catch(e){}
};

BabylonViewerJS.prototype.setAutoRotate = function(enabled){
    this.autoRotate = !!enabled;
};

BabylonViewerJS.prototype.zoomToFit = function(){
    this._frameModel();
};

BabylonViewerJS.prototype.dispose = function(){
    try {
        this.engine.stopRenderLoop();
        this.scene.dispose();
        this.engine.dispose();
    } catch(e){}
};

/* expose */
global.BabylonViewerJS = BabylonViewerJS;
console.log('babylon-viewer.js loaded');
})(window);
